= Quarkus
Alex Soto <https://twitter.com/alexsotob>;
:authorbio_1: Java Champion and SW Engineer at Red Hat
:pdf-width: 508mm
:pdf-height: 361mm
:version: v0.13.3

== What is Quarkus?

Quarkus (https://quarkus.io/) is a Kubernetes Native Java stack tailored for GraalVM & OpenJDK HotSpot, crafted from the best of breed Java libraries and standards.
Also focused on developer experience, making things just work with little to no configuration and allowing to do live coding.

== Getting Started

Quarkus comes with a Maven archetype to scaffold a very simple starting project.

```bash
mvn io.quarkus:quarkus-maven-plugin:0.13.3:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.quickstart.GreetingResource" \
    -Dpath="/hello"
```

This creates a simple JAX-RS resource called `GreetingResource`.

```java
@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
```

== Extensions

Quarkus comes with extensions to integrate with some libraries such as JSON-B, Camel or MicroProfile libraries.
To list all available extensions just run:

```bash
./mvnw quarkus:list-extensions
```

And to register the extensions into build tool:

```bash
./mvnw quarkus:add-extension -Dextensions=""
```

TIP: `extensions` property supports CSV format to register more than one extension.

== Adding Configuration Parameters

To add configuration to your application, Quarkus relies on MicroProfile Config spec (https://github.com/eclipse/microprofile-config).

```java
@ConfigProperty(name = "greetings.message")
String message;

@ConfigProperty(name = "greetings.message", 
                defaultValue = "Hello")
String messageWithDefault;

@ConfigProperty(name = "greetings.message")
Optional<String> optionalMessage;
```

Properties can be set as environment variable, system property or in `src/main/resources/application.properties`.

```properties
greetings.message = Hello World
```

== Injection

Quarkus is based on CDI 2.0 to implement injection of code.
It is not fully supported and only a subset of the specification is implemented.


```java
@ApplicationScoped
public class GreetingService {

    public String message(String message) {
        return message.toUpperCase();
    }
}
```

Scope annotation is mandatory to make the bean discoverable by CDI.

```java
@Inject
GreetingService greetingService;
```

IMPORTANT: Quarkus is designed with Substrate VM in mind. For this reason we encourage you to use _package-private_ scope instead of _private_.

== JSON Marshalling/Unmarshalling

To work with `JSON-B` you need to add a dependency:

```bash
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-resteasy-jsonb"
```

Any POJO is marshalled/unmarshalled automatically.

```java
public class Sauce {
    private String name;
    private long scovilleHeatUnits;

    // getter/setters
}
```

JSON equivalent:

```json
{
	"name":"Blair's Ultra Death",
	"scovilleHeatUnits": 1100000
}
```

In a `POST` endpoint example:

```java
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response create(Sauce sauce) {
    // Create Sauce
    return Response.created(URI.create(sauce.getId()))
            .build();
}
```

== Persistence

Quarkus works with JPA(Hibernate) as persistence solution.
But also provides an Active Record pattern (https://en.wikipedia.org/wiki/Active_record_pattern) implementation under Panache project.

To use database access you also need to add Quarkus JDBC drivers instead of the original ones.
At this time `H2`, `MariaDB` and `PostgreSQL` drivers are supported.

```bash
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-hibernate-orm-panache, 
                io.quarkus:quarkus-jdbc-mariadb"
```

```java
@Entity
public class Developer extends PanacheEntity {

    // id field is implicit

    public String name;
}
```

And configuration in `src/main/resources/application.properties`:

```properties
quarkus.datasource.url=jdbc:mariadb://localhost:3306/mydb
quarkus.datasource.driver=org.mariadb.jdbc.Driver
quarkus.datasource.username=developer
quarkus.datasource.password=developer
quarkus.hibernate-orm.database.generation=update
```

Database operations:

```java
// Insert
Developer developer = new Developer();
developer.name = "Alex";
developer.persist();

// Find All
Developer.findAll().list();

// Find By Query
Developer.find("name", "Alex").firstResult();

// Delete
Developer developer = new Developer();
developer.id = 1;
developer.delete();

// Delete By Query
long numberOfDeleted = Developer.delete("name", "Alex");
```

Remember to annotate methods with `@Transactional` annotation to make changes persisted in database.

If queries start with keyword `from` then they are treat as _HQL_ query, if not then next short form is supported:

* `order by` which expands to `from EntityName order by ...`
* `<columnName>` which expands to `from EntityName where <columnName>=?`
* `<query>` which is expanded to `from EntityName where <query>`

*Static Methods*

|===	
| Field | Parameters | Return

a| `findById`
a| `Object`
a| Returns object or null if not found.

a| `find`
a| `String`, [`Object...`, `Map<String, Object>`, `Parameters`]
a| Lists of entities meeting given query with parameters set.

a| `find`
a| `String`, `Sort`, [`Object...`, `Map<String, Object>`, `Parameters`]
a| Lists of entities meeting given query with parameters set sorted by `Sort` attribute/s.

a| `findAll`
a| 
a| Finds all entities.

a| `findAll`
a| `Sort`
a| Finds all entities sorted by `Sort` attribute/s.

a| `stream`
a| `String`, [`Object...`, `Map<String, Object>`, `Parameters`]
a| `java.util.stream.Stream` of entities meeting given query with parameters set.

a| `stream`
a| `String`, `Sort`, [`Object...`, `Map<String, Object>`, `Parameters`]
a| `java.util.stream.Stream` of entities meeting given query with parameters set sorted by `Sort` attribute/s.

a| `streamAll`
a| 
a| `java.util.stream.Stream` of all entities.

a| `streamAll`
a| `Sort`
a| `java.util.stream.Stream` of all entities sorted by `Sort` attribute/s.

a| `count`
a| 
a| `Number of entities.

a| `count`
a| `String`, [`Object...`, `Map<String, Object>`, `Parameters`]
a| Number of entities meeting given query with parameters set.

a| `deleteAll`
a| 
a| Number of deleted entities.

a| `delete`
a| `String`, [`Object...`, `Map<String, Object>`, `Parameters`]
a| Number of deleted entities meeting given query with parameters set.

a| `persist`
a| [`Iterable`, `Steram`, `Object...`]
a| 
|===

INFO: Panache also support _DAO_ pattern by providing `PanacheRepository<TYPE>` interface to be implemented by your _repository_ class.

== Rest Client

Quarkus implements MicroProfile Rest Client (https://github.com/eclipse/microprofile-rest-client) spec:

```bash
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-smallrye-rest-client"
```

To get content from http://worldclockapi.com/api/json/cet/now you need to create a service interface:

```java
@Path("/api")
@RegisterRestClient
public interface WorldClockService {

    @GET @Path("/json/cet/now")
    @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON) 
    WorldClock getNow();
}
```

And configure the hostname at `application.properties`:

```properties
org.acme.quickstart.WorldClockService/mp-rest/url=http://worldclockapi.com
```

Injecting the client:

```java
@Inject
@RestClient
WorldClockService worldClockService;
```

*Customizing headers*

You can customize the headers passed by implementing MicroProfile `ClientHeadersFactory` annotation:

```java
@RegisterForReflection
public class BaggageHeadersFactory 
                implements ClientHeadersFactory {
    @Override
    public MultivaluedMap<String, String> update(
        MultivaluedMap<String, String> incomingHeaders, 
        MultivaluedMap<String, String> clientOutgoingHeaders) {}
}
```

And registering it in the client using `RegisterClientHeaders` annotation.

```java
@RegisterClientHeaders(BaggageHeadersFactory.class)
@RegisterRestClient
public interface WorldClockService {}
```

Or statically set:

xxxx

== Validator

Quarkus uses Hibernate Validator to validate input/output of of REST services and business services.

```bash
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-hibernate-validator"
```

Annotate POJO objects with validator annotations such as: `@NotNull`, `@Digits`, `@NotBlank`, `@Min`, `@Max`, ...

```java
public class Sauce {

    @NotBlank(message = "Name may not be blank")
    private String name;
    @Min(0)
    private long scovilleHeatUnits;

    // getter/setters
}

To validate that an object is valid you need to annotate where is sued with `@Valid` annotation:

```java
public Response create(@Valid Sauce sauce) {}
```

TIP: If a validation error is triggered, a violation report is generated and serialized as JSON. If you want to manipulate the output, you need to catch in the code the `ConstraintViolationException` exception.

*Create Your Own Validations*

xxx

*Manual Validation*

You can call the validation process manualy instead of relaying to `@Valid` by injecting `Validator` class.

```java
@Inject
Validator validator;
```

And use it:

```java
Set<ConstraintViolation<Sauce>> violations = validator.validate(sauce);
```

== Reactive Programming

Quarkus implements MicroProfile Reactive spec and uses RXJava2 to provide reactive programming model.

```bash
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-smallrye-reactive-streams-operators"
```

Asynchronous HTTP endpoint is implemented by returning Java `CompletionStage`.
You can create this class either manually or using MicroProfile Reactive Streams spec:

```java
@GET
@Path("/reactive")
@Produces(MediaType.TEXT_PLAIN)
public CompletionStage<String> getHello() {
    return ReactiveStreams.of("h", "e", "l", "l", "o")
    .map(String::toUpperCase)
    .toList()
    .run()
    .thenApply(list -> list.toString());
}
```

Creating streams is also easy, you just need to return `Publisher` object.

```java
@GET
@Path("/stream")
@Produces(MediaType.SERVER_SENT_EVENTS)
public Publisher<String> publishers() {
        return Flowable
        .interval(500, TimeUnit.MILLISECONDS)
        .map(s -> atomicInteger.getAndIncrement())
        .map(i -> Integer.toString(i));
}
```

== Security

== Observability

*Health Checks*

Quarkus relies on MicroProfile Health spec to provide health checks.

```bash
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-smallrye-health"
```

By just adding this extension, an endpoint is registered to `/health` providing a default health check.

```json
{
    "outcome": "UP",
    "checks": [
    ]
}
```

To create a custom health check you need to implement the `HealthCheck` interface and annotate it with `@Health` annotation.

```java
@Health
public class DatabaseHealthCheck implements HealthCheck {
    @Override
    public HealthCheckResponse call() {
        HealthCheckResponseBuilder responseBuilder = 
            HealthCheckResponse.named("Database connection");

        try {
            checkDatabaseConnection();
            responseBuilder.withData("connection", true);
            responseBuilder.up();
        } catch (IOException e) {
            // cannot access the database
            responseBuilder.down()
                    .withData("error", e.getMessage());
        }
        return responseBuilder.build();
    }
}
```

Build next output:

```json

{
    "outcome": "UP",
    "checks": [
        {
            "name": "Database connection",
            "state": "UP",
            "data": {
                "connection": true
            }
        }
    ]
}
```

*Metrics*

Quarkus can utilize the MicroProfile Metrics specification to provide metrics support.

```bash
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-smallrye-metrics"
```

The metrics can be read remotely using JSON format or the OpenMetrics format.
By just adding the extension, an endpoint is registered at `/metrics` providing default metrics.

MicroProfile Metrics comes with some annotations to add smoe specific monitoring values:

|===	
| Annotation | Description

a|`@Timed`
a|Marking a method, constructor, or class as timed.

a|`@Metered`
a|Marking a method, constructor, or class as metered.

a|`@Counted`
a|Marking a method, constructor, or class as counted.

a|`@Gauge`
a|Marking a method or field as a gauge.

a|`@Metric`
a|Requesting that a metric be injected or registered.
|===

```java
@GET
//...
@Timed(name = "checksTimer", 
description = "A measure of how long it takes to perform a hello.", 
unit = MetricUnits.MILLISECONDS)
public String hello() {}
```

`@Gauge` annotation returning a measure as gauge.

```java
@Gauge(name = "hottestSauce", unit = MetricUnits.NONE, 
description = "Hottest Sauce so far.")
public Long hottestSauce() {}
```

Injecting using `@Metric`.

```java
@Inject
@Metric(name = "histogram")
Histogram historgram;
```

*Tracing*

Quarkus can utilize the MicroProfile OpenTracing spec to provide tracing support.

```bash
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-smallrye-opentracing"
```

By default, requests sent to any endpoint are traced without any code changes being required.

This extensions includes OpenTracing support and `Jaeger` tracer.

Jaeger tracer configuration:

```properties
quarkus.jaeger.service-name=myservice
quarkus.jaeger.sampler-type=const
quarkus.jaeger.sampler-param=1
quarkus.jaeger.endpoint=http://localhost:14268/api/traces
```

`@Traced` annotation can be set to disable tracing at class or method level.

`Tracer` class can be injected into class.

```java
@Inject
Tracer tracer;

tracer.activeSpan().setBaggageItem("key", "value");
```

== Cloud



K8s
Native

== Testing