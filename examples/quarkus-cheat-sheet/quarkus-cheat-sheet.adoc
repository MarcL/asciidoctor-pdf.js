= Quarkus Cheat-Sheet

ifndef::site[]

Alex Soto <https://twitter.com/alexsotob>;
:authorbio: Java Champion and SW Engineer at Red Hat
:pdf-width: 508mm
:pdf-height: 361mm

include::attributes.adoc[]

endif::site[]

ifdef::site[]
icon:file-pdf-o[] {pdf-download}[Download the Cheat-Sheet as PDF].
endif::site[]

== What is Quarkus?

Quarkus (https://quarkus.io/) is a Kubernetes Native Java stack tailored for GraalVM & OpenJDK HotSpot, crafted from the best of breed Java libraries and standards.
Also focused on developer experience, making things just work with little to no configuration and allowing to do live coding.

Cheat-sheet tested with *Quarkus {version}*.

== Getting Started

Quarkus comes with a Maven archetype to scaffold a very simple starting project.

[source, bash]
----
mvn io.quarkus:quarkus-maven-plugin:0.14.0:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.quickstart.GreetingResource" \
    -Dpath="/hello"
----

This creates a simple JAX-RS resource called `GreetingResource`.

[source, java]
----
@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
----

== Extensions

Quarkus comes with extensions to integrate with some libraries such as JSON-B, Camel or MicroProfile spec.
To list all available extensions just run:

[source, bash]
----
./mvnw quarkus:list-extensions
----

And to register the extensions into build tool:

[source, bash]
----
./mvnw quarkus:add-extension -Dextensions=""
----

TIP: `extensions` property supports CSV format to register more than one extension at once.

<<<

== Application Lifecycle
// tag::update_1_3[]
You can be notified when the application starts and when stops by observing `StartupEvent` and `ShutdownEvent` events.

[source, java]
----
@ApplicationScoped
public class ApplicationLifecycle {
    void onStart(@Observes StartupEvent event) {}
    void onStop(@Observes ShutdownEvent event) {}
}
----
// end::update_1_3[]

== Adding Configuration Parameters

To add configuration to your application, Quarkus relies on MicroProfile Config spec (https://github.com/eclipse/microprofile-config).

[source, java]
----
@ConfigProperty(name = "greetings.message")
String message;

@ConfigProperty(name = "greetings.message", 
                defaultValue = "Hello")
String messageWithDefault;

@ConfigProperty(name = "greetings.message")
Optional<String> optionalMessage;
----

Properties can be set as environment variable, system property or in `src/main/resources/application.properties`.

[source, properties]
----
greetings.message = Hello World
----

== Injection

Quarkus is based on CDI 2.0 to implement injection of code.
It is not fully supported and only a subset of the specification is implemented (https://quarkus.io/guides/cdi-reference).


[source, java]
----
@ApplicationScoped
public class GreetingService {

    public String message(String message) {
        return message.toUpperCase();
    }
}
----

Scope annotation is mandatory to make the bean discoverable by CDI.

[source, java]
----
@Inject
GreetingService greetingService;
----

IMPORTANT: Quarkus is designed with Substrate VM in mind. For this reason, we encourage you to use _package-private_ scope instead of _private_.

== JSON Marshalling/Unmarshalling

To work with `JSON-B` you need to add a dependency:

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-resteasy-jsonb"
----

Any POJO is marshaled/unmarshalled automatically.

[source, java]
----
public class Sauce {
    private String name;
    private long scovilleHeatUnits;

    // getter/setters
}
----

JSON equivalent:

[source, json]
----
{
	"name":"Blair's Ultra Death",
	"scovilleHeatUnits": 1100000
}
----

In a `POST` endpoint example:

[source, java]
----
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response create(Sauce sauce) {
    // Create Sauce
    return Response.created(URI.create(sauce.getId()))
            .build();
}
----

== Persistence

Quarkus works with JPA(Hibernate) as persistence solution.
But also provides an Active Record pattern (https://en.wikipedia.org/wiki/Active_record_pattern) implementation under Panache project.

To use database access you need to add Quarkus JDBC drivers instead of the original ones.
At this time `H2`, `MariaDB` and `PostgreSQL` drivers are supported.

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-hibernate-orm-panache, 
                io.quarkus:quarkus-jdbc-mariadb"
----

[source, java]
----
@Entity
public class Developer extends PanacheEntity {

    // id field is implicit

    public String name;
}
----

And configuration in `src/main/resources/application.properties`:

[source, properties]
----
quarkus.datasource.url=jdbc:mariadb://localhost:3306/mydb
quarkus.datasource.driver=org.mariadb.jdbc.Driver
quarkus.datasource.username=developer
quarkus.datasource.password=developer
quarkus.hibernate-orm.database.generation=update
----

Database operations:

[source, java]
----
// Insert
Developer developer = new Developer();
developer.name = "Alex";
developer.persist();

// Find All
Developer.findAll().list();

// Find By Query
Developer.find("name", "Alex").firstResult();

// Delete
Developer developer = new Developer();
developer.id = 1;
developer.delete();

// Delete By Query
long numberOfDeleted = Developer.delete("name", "Alex");
----

Remember to annotate methods with `@Transactional` annotation to make changes persisted in the database.

If queries start with the keyword `from` then they are treated as _HQL_ query, if not then next short form is supported:

* `order by` which expands to `from EntityName order by ...`
* `<columnName>` which expands to `from EntityName where <columnName>=?`
* `<query>` which is expanded to `from EntityName where <query>`

*Static Methods*

|===	
| Field | Parameters | Return

a| `findById`
a| `Object`
a| Returns object or null if not found.

a| `find`
a| `String`, [`Object...`, `Map<String, Object>`, `Parameters`]
a| Lists of entities meeting given query with parameters set.

a| `find`
a| `String`, `Sort`, [`Object...`, `Map<String, Object>`, `Parameters`]
a| Lists of entities meeting given query with parameters set sorted by `Sort` attribute/s.

a| `findAll`
a| 
a| Finds all entities.

a| `findAll`
a| `Sort`
a| Finds all entities sorted by `Sort` attribute/s.

a| `stream`
a| `String`, [`Object...`, `Map<String, Object>`, `Parameters`]
a| `java.util.stream.Stream` of entities meeting given query with parameters set.

a| `stream`
a| `String`, `Sort`, [`Object...`, `Map<String, Object>`, `Parameters`]
a| `java.util.stream.Stream` of entities meeting given query with parameters set sorted by `Sort` attribute/s.

a| `streamAll`
a| 
a| `java.util.stream.Stream` of all entities.

a| `streamAll`
a| `Sort`
a| `java.util.stream.Stream` of all entities sorted by `Sort` attribute/s.

a| `count`
a| 
a| `Number of entities.

a| `count`
a| `String`, [`Object...`, `Map<String, Object>`, `Parameters`]
a| Number of entities meeting given query with parameters set.

a| `deleteAll`
a| 
a| Number of deleted entities.

a| `delete`
a| `String`, [`Object...`, `Map<String, Object>`, `Parameters`]
a| Number of deleted entities meeting given query with parameters set.

a| `persist`
a| [`Iterable`, `Steram`, `Object...`]
a| 
|===

TIP: Panache also supports _DAO_ pattern by providing `PanacheRepository<TYPE>` interface to be implemented by your _repository_ class.

== Rest Client

Quarkus implements MicroProfile Rest Client (https://github.com/eclipse/microprofile-rest-client) spec:

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-smallrye-rest-client"
----

To get content from http://worldclockapi.com/api/json/cet/now you need to create a service interface:

[source, java]
----
@Path("/api")
@RegisterRestClient
public interface WorldClockService {

    @GET @Path("/json/cet/now")
    @Produces(MediaType.APPLICATION_JSON) 
    WorldClock getNow();

    @GET
    @Path("/json/{where}/now")
    @Produces(MediaType.APPLICATION_JSON) 
    WorldClock getSauce(@BeanParam 
                            WorldClockOptions worldClockOptions);

}
----

[source, java]
----
public class WorldClockOptions {
    @HeaderParam("Authorization")
    String auth;

    @PathParam("where")
    String where;   
}
----

And configure the hostname at `application.properties`:

<<<

[source, proeprties]
----
org.acme.quickstart.WorldClockService/mp-rest/url=
        http://worldclockapi.com
----

Injecting the client:

[source, java]
----
@Inject
@RestClient
WorldClockService worldClockService;
----

// tag::update_1_1[]
If invokation happens within a JAX-RS resource class, you can propagate headers from incoming request to the outgoing request by using next configuartion property.

[source, properties]
----
org.eclipse.microprofile.rest.client.propagateHeaders=
            Authorization,MyCustomHeader
----
// end::update_1_1[]

TIP: You can still use the JAX-RS client without any problem `ClientBuilder.newClient().target(...)`

*Adding headers*

You can customize the headers passed by implementing MicroProfile `ClientHeadersFactory` annotation:

[source, java]
----
@RegisterForReflection
public class BaggageHeadersFactory 
                implements ClientHeadersFactory {
    @Override
    public MultivaluedMap<String, String> update(
        MultivaluedMap<String, String> incomingHeaders, 
        MultivaluedMap<String, String> clientOutgoingHeaders) {}
}
----

And registering it in the client using `RegisterClientHeaders` annotation.

[source, java]
----
@RegisterClientHeaders(BaggageHeadersFactory.class)
@RegisterRestClient
public interface WorldClockService {}
----

Or statically set:

[source, java]
----
@GET
@ClientHeaderParam(name="X-Log-Level", value="ERROR")
Response getNow();
----

*Asynchronous*

A method on client interface can return a `CompletionStage` class to be executed asynchronously.

[source, java]
----
@GET @Path("/json/cet/now")
@Produces(MediaType.APPLICATION_JSON) 
CompletionStage<WorldClock> getNow();
----

== Fault Tolerance
// tag::update_1_2[]
Quarkus uses MicroProfile Fault Tolerance (https://github.com/eclipse/microprofile-fault-tolerance) spec:

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-smallrye-fault-tolerance"
----

MicroProfile Fault Tolerance spec uses CDI interceptor and it can be used in several elements such as CDI bean, JAX-RS resource or MicroProfile Rest Client.

To do automatic *retries* on a method:

[source, java]
----
@Path("/api")
@RegisterRestClient
public interface WorldClockService {
    
    @GET @Path("/json/cet/now")
    @Produces(MediaType.APPLICATION_JSON)
    @Retry(maxRetries = 2)
    WorldClock getNow();

}
----

You can set fallback code in case of an error by using `@Fallback` annotation:

[source, java]
----
@Retry(maxRetries = 1)
@Fallback(fallbackMethod = "fallbackMethod")
WorldClock getNow(){}

public String fallbackMethod() {
    return "It could beworse";
}
----

`fallbackMethod` must have the same parameters and return type as the annotated method.

You can also set logic into a class that implements `FallbackHandler` interface:

[source, java]
----
public class RecoverFallback 
            implements FallbackHandler<String> {
    @Override
    public String handle(ExecutionContext context) {
        return "It could be worse";
    }
}
----

<<<

And set it in the annotation as value `@Fallback(RecoverFallback.class)`.

In case you want to use *circuit breaker* pattern:

[source, java]
----
@CircuitBreaker(requestVolumeThreshold = 4, 
                failureRatio=0.75, 
                delay = 1000)
WorldClock getNow(){}
----

If 3 `(4 x 0.75)` failures occur among the rolling window of 4 consecutive invocations then the circuit is opened for 1000 ms and then be back to half open.
If the invocation succeeds then the circuit is back to closed again.

You can use *bulkahead* pattern to limit the number of concurrent access to the same resource. 
If the operation is synchronous it uses a semaphore approach, if it is asynchronous a thread-pool one.
When a request cannot be processed `BulkheadException` is thrown.
It can be used together with any other fault tolerance annotation. 

[source, java]
----
@Bulkhead(5)
@Retry(maxRetries = 4, 
       delay = 1000,
       retryOn = BulkheadException.class)
WorldClock getNow(){}
----

Fault tolerance annotations:

|===	
| Annotation | Properties

a|`@Timeout`
a|`unit`

a|`@Retry`
a|`maxRetries`, `delay`, `delayUnit`, `maxDuration`, `durationUnit`, `jitter`, `jitterDelayUnit`, `retryOn`, `abortOn`

a|`@Fallback`
a|`fallbackMethod`

a|`@Bulkhead`
a|`waitingTaskQueue` (only valid in asynchronous)

a|`@CircuitBreaker`
a|`failOn`, `delay`, `delayUnit`, `requestVolumeThreshold`, `failureRatio`, `successThreshold`

a|`@Asynchronous`
a|
|===

<<<

You can override annotation parameters via configuration file using property `[classname/methodname/]annotation/parameter`:

[source, properties]
----
org.acme.quickstart.WorldClock/getNow/Retry/maxDuration=30
# Class scope
org.acme.quickstart.WorldClock/Retry/maxDuration=3000
# Global
Retry/maxDuration=3000
----

You can also enable/disable policies using special parameter `enabled`.

[source, properties]
----
org.acme.quickstart.WorldClock/getNow/Retry/enabled=false
# Disable everything except fallback
MP_Fault_Tolerance_NonFallback_Enabled=false
----

TIP: MicroProfile Fault Tolerance integrats with MicroProfile Metrics spec. You can disable it by setting `MP_Fault_Tolerance_Metrics_Enabled` to false.
// end::update_1_2[]

== Validator

Quarkus uses Hibernate Validator (https://hibernate.org/validator/) to validate input/output of REST services and business services using Bean validation spec.

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-hibernate-validator"
----

Annotate POJO objects with validator annotations such as: `@NotNull`, `@Digits`, `@NotBlank`, `@Min`, `@Max`, ...

[source, java]
----
public class Sauce {

    @NotBlank(message = "Name may not be blank")
    private String name;
    @Min(0)
    private long scovilleHeatUnits;

    // getter/setters
}
----

To validate that an object is valid you need to annotate where is used with `@Valid` annotation:

[source, java]
----
public Response create(@Valid Sauce sauce) {}
----

TIP: If a validation error is triggered, a violation report is generated and serialized as JSON. If you want to manipulate the output, you need to catch in the code the `ConstraintViolationException` exception.

*Create Your Custom Constraints*

First you need to create the custom annotation:

[source, java]
----
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, 
            PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { NotExpiredValidator.class})
public @interface NotExpired {

    String message() default "Sauce must not be expired";
    Class<?>[] groups() default { };
    Class<? extends Payload>[] payload() default { };

}
----

You need to implement the validator logic in a class that implements `ConstraintValidator`. 

[source, java]
----
public class NotExpiredValidator 
    implements ConstraintValidator<NotExpired, LocalDate> 
    {

    @Override
    public boolean isValid(LocalDate value, 
                            ConstraintValidatorContext ctx) {
        if ( value == null ) {
            return true;
        }
        LocalDate today = LocalDate.now();
        return ChronoUnit.YEARS.between(today, value) > 0;
    }
}
----

And use it normally:

[source, java]
----
@NotExpired
@JsonbDateFormat(value = "yyyy-MM-dd")
private LocalDate expired;
----

*Manual Validation*

You can call the validation process manually instead of relaying to `@Valid` by injecting `Validator` class.

[source, java]
----
@Inject
Validator validator;
----

And use it:

[source, java]
----
Set<ConstraintViolation<Sauce>> violations = 
            validator.validate(sauce);
----

== Security and JWT
// tag::update_1_5[]
Quarkus implements https://github.com/eclipse/microprofile-jwt-auth[MicroProfile JWT RBAC spec].

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="io.quarkus:quarkus-smallrye-jwt"
----

Minimum JWT required claims: `typ`, `alg`, `kid`, `iss`, `sub`, `exp`, `iat`, `jti`, `upn`, `groups`.



// end::update_1_5[]

== Reactive Programming

Quarkus implements https://github.com/eclipse/microprofile-reactive-streams-operators[MicroProfile Reactive spec] and uses RXJava2 to provide reactive programming model.

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="
    io.quarkus:quarkus-smallrye-reactive-streams-operators"
----

Asynchronous HTTP endpoint is implemented by returning Java `CompletionStage`.
You can create this class either manually or using MicroProfile Reactive Streams spec:

[source, java]
----
@GET
@Path("/reactive")
@Produces(MediaType.TEXT_PLAIN)
public CompletionStage<String> getHello() {
    return ReactiveStreams.of("h", "e", "l", "l", "o")
    .map(String::toUpperCase)
    .toList()
    .run()
    .thenApply(list -> list.toString());
}
----

Creating streams is also easy, you just need to return `Publisher` object.

[source, java]
----
@GET
@Path("/stream")
@Produces(MediaType.SERVER_SENT_EVENTS)
public Publisher<String> publishers() {
        return Flowable
        .interval(500, TimeUnit.MILLISECONDS)
        .map(s -> atomicInteger.getAndIncrement())
        .map(i -> Integer.toString(i));
}
----

== Reactive Messaging
// tag::update_1_4[]
Quarkus relies on MicroProfile Reactive Messaging spec (https://github.com/eclipse/microprofile-reactive-messaging) to implement reactive messaging streams.

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="io.quarkus:quarkus-smallrye-reactive-messaging"
----

You can just start using in-memory streams by using `@Incoming` to produce data and `@Outgoing` to consume data.

Produce every 5 seconds one piece of data.

[source, java]
----
@ApplicationScoped
public class ProducerData {

    @Outgoing("my-in-memory")
    public Flowable<Integer> generate() {
        return Flowable.interval(5, TimeUnit.SECONDS)
                .map(tick -> random.nextInt(100));
    }
}
----

Consumes generated data from `my-in-memory` stream.

[source, java]
----
@ApplicationScoped
public class ConsumerData {
    @Incoming("my-in-memory")
    public void randomNumber(int randomNumber) {
        System.out.println("Received " + randomNumber);
    }
}
----

You can also inject an strem as field:

[source, java]
----
@Inject
@Stream("my-in-memory") Publisher<Integer> randomRumbers;
----

Possible return types:

*Kafka*

To integrate with Kafka you need to add next extensions:

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="io.quarkus:quarkus-smallrye-reactive-messaging-kafka, 
                  io.quarkus:quarkus-vert"
----

Then `@Outgoing`, `@Incoming` or `@Stream` can be set with Kafka streams.

You need also need to configure Kafka connector following next schema: `smallrye.messaging.[sink|source].\{stream-name\}.<property>=<value>` 

[source, properties]
----
smallrye.messaging.source.prices.type=
    io.smallrye.reactive.messaging.kafka.Kafka
smallrye.messaging.source.prices.topic=
    prices
smallrye.messaging.source.prices.bootstrap.servers=
    localhost:9092
smallrye.messaging.source.prices.key.deserializer=
    org.apache.kafka.common.serialization.StringDeserializer
smallrye.messaging.source.prices.value.deserializer=
    org.apache.kafka.common.serialization.IntegerDeserializer
smallrye.messaging.source.prices.group.id=
    my-group-id
----

A complete list of supported properties are in Kafka site. For https://kafka.apache.org/documentation/#producerconfigs[producer] and for https://kafka.apache.org/documentation/#consumerconfigs[consumer]

IMPORTANT: If stream is not configured then it is assumed to be an in-memory stream.

// end::update_1_4[]

== Observability

*Health Checks*

Quarkus relies on MicroProfile Health spec (https://github.com/eclipse/microprofile-health) to provide health checks.

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-smallrye-health"
----

By just adding this extension, an endpoint is registered to `/health` providing a default health check.

[source, json]
----
{
    "outcome": "UP",
    "checks": [
    ]
}
----

To create a custom health check you need to implement the `HealthCheck` interface and annotate it with `@Health` annotation.

[source, java]
----
@Health
public class DatabaseHealthCheck implements HealthCheck {
    @Override
    public HealthCheckResponse call() {
        HealthCheckResponseBuilder responseBuilder = 
            HealthCheckResponse.named("Database conn");

        try {
            checkDatabaseConnection();
            responseBuilder.withData("connection", true);
            responseBuilder.up();
        } catch (IOException e) {
            // cannot access the database
            responseBuilder.down()
                    .withData("error", e.getMessage());
        }
        return responseBuilder.build();
    }
}
----

Builds the next output:

[source, json]
----

{
    "outcome": "UP",
    "checks": [
        {
            "name": "Database connection",
            "state": "UP",
            "data": {
                "connection": true
            }
        }
    ]
}
----

*Metrics*

Quarkus can utilize the MicroProfile Metrics spec (https://github.com/eclipse/microprofile-metrics) to provide metrics support.

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-smallrye-metrics"
----

The metrics can be read remotely using JSON format or the OpenMetrics format.
By just adding the extension, an endpoint is registered at `/metrics` providing default metrics.

MicroProfile Metrics comes with some annotations to add specific monitoring values:

|===	
| Annotation | Description

a|`@Timed`
a|Marking a method, constructor, or class as timed.

a|`@Metered`
a|Marking a method, constructor, or class as metered.

a|`@Counted`
a|Marking a method, constructor, or class as counted.

a|`@Gauge`
a|Marking a method or field as a gauge.

a|`@Metric`
a|Requesting that a metric be injected or registered.
|===

[source, java]
----
@GET
//...
@Timed(name = "checksTimer", 
description = "A measure of how long it takes 
                                to perform a hello.", 
unit = MetricUnits.MILLISECONDS)
public String hello() {}
----

`@Gauge` annotation returning a measure as a gauge.

[source, java]
----
@Gauge(name = "hottestSauce", unit = MetricUnits.NONE, 
description = "Hottest Sauce so far.")
public Long hottestSauce() {}
----

Injecting a histogram using `@Metric`.

[source, java]
----
@Inject
@Metric(name = "histogram")
Histogram historgram;
----

*Tracing*

Quarkus can utilize the MicroProfile OpenTracing spec (https://github.com/eclipse/microprofile-opentracing) to provide tracing support.

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-smallrye-opentracing"
----

By default, requests sent to any endpoint are traced without any code changes being required.

This extension includes OpenTracing support and `Jaeger` tracer.

Jaeger tracer configuration:

[source, properties]
----
quarkus.jaeger.service-name=myservice
quarkus.jaeger.sampler-type=const
quarkus.jaeger.sampler-param=1
quarkus.jaeger.endpoint=http://localhost:14268/api/traces
----

`@Traced` annotation can be set to disable tracing at class or method level.

`Tracer` class can be injected into the class.

[source, java]
----
@Inject
Tracer tracer;

tracer.activeSpan().setBaggageItem("key", "value");
----

== Cloud

*Native*

You can build a native image by using GraalVM.
The common use case is creating a Docker image so you can execute the next commands:

[source, bash]
----
./mvnw package -Pnative -Dnative-image.docker-build=true

docker build -f src/main/docker/Dockerfile.native 
                    -t quarkus/getting-started .
docker run -i --rm -p 8080:8080 quarkus/getting-started
----

*Kubernetes*

Quarks can use ap4k (https://github.com/ap4k/ap4k) to generate Kubernetes resources.

[source, bash]
----
./mvnw quarkus:add-extensions 
    -Dextensions="io.quarkus:quarkus-kubernetes"
----

Running `./mvnw package` the Kubernetes resources are created at `target/wiring-classes/META-INF/kubernetes/` directory.

|===	
| Property | Default | Description

a| `quarkus.kubernetes.group`
a| Current username
a| Set Docker Username.

a| `quarkus.application.name`
a| Current project name
a| Project name
|===

== Logging

You can configure how Quarkus logs:

[source, properties]
----
quarkus.log.console.enable=true
quarkus.log.console.level=DEBUG
quarkus.log.console.color=false

quarkus.log.category."com.lordofthejars".level=DEBUG
----

Prefix is `quarkus.log`.

|===	
| Property | Default | Description

a| `console.enable`
a| `true`
a| Console logging enabled.

a| `console.format`
a| `%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n`
a| Format pattern to use for logging.

a| `console.level`
a| `INFO`
a| Minimum log level.

a| `console.color`
a| `INFO`
a| Allow color rendering.

a| `file.enable`
a| `false`
a| File logging enabled.

a| `file.format`
a| `%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{3.}] (%t) %s%e%n`
a| Format pattern to use for logging.

a| `file.level`
a| `ALL`
a| Minimum log level.

a| `file.path`
a| `quarkus.log`
a| The path to log file.

a| `category."<category-name>".level`
a| `INFO`
a| Minimum level category.

a| `level`
a| `INFO`
a| Default minimum level.
|===

== Testing

When you generate the Quarkus project with the archetype, test dependencies with JUnit 5 are registered automatically, but also the Rest-Assured library to test RESt endpoints.

To package and run the application for testing:

[source, java]
----
@QuarkusTest
public class GreetingResourceTest {

    @Test
    public void testHelloEndpoint() {
        given()
          .when().get("/hello")
          .then()
             .statusCode(200)
             .body(is("hello"));
    }
}
----

Test port can be modified by using `quarkus.http.test-port` configuration property.

You can also inject the URL where Quarkus is started:

[source, java]
----
@TestHTTPResource("index.html") 
URL url;
----

If you need to provide an alternative implementation of a service (for testing purposes) you can do it by using CDI `@Alternative` annotation using it in the test service placed at `src/test/java`:

[source, java]
----
@Alternative
@Priority(1)
@ApplicationScoped
public class MockExternalService extends ExternalService {}
----

IMPORTANT: This does not work when using native image testing.

To test native executables you can annotate the test with `@SubstrateTest`.

== Resources

* https://quarkus.io/guides/
* https://www.youtube.com/user/lordofthejars